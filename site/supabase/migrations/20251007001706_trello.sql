-- The "Trello Clone" entities - boards, columns and tasks

create table if not exists public.boards (
    id          bigint generated by default as identity primary key,
    created_at  timestamptz not null default now(),
    updated_at  timestamptz not null default now(),
    title       text,
    description text,
    color       text default 'bg-blue-500'::text,
    
    creator     text not null
);

alter table public.boards enable row level security;


create table if not exists public.columns (
    id         bigint generated by default as identity primary key,
    created_at timestamptz not null default now(),
    board_id   bigint references public.boards(id) on delete cascade,
    title      text not null,
    sort_order integer default 0
);

alter table public.columns enable row level security;

create index idx_columns_board_id on public.columns (board_id);

create index idx_columns_id_include_board_id on columns (id) include (board_id);


create table if not exists public.tasks (
    id          bigint generated by default as identity primary key,
    created_at  timestamptz not null default now(),
    column_id   bigint references public.columns(id) on delete cascade,
    assignee    text,
    title       text not null,
    description text,
    due_date    date,
    priority    text default 'medium'::text,
    sort_order  integer default 0
);

alter table public.tasks enable row level security;

create index idx_tasks_column_id on public.tasks (column_id);


create table if not exists public.users_boards (
  user_id   uuid not null references auth.users(id) on delete cascade,
  board_id  bigint not null references public.boards(id) on delete cascade,
  joined_at timestamptz not null default now(),

  primary key (user_id, board_id)
);

alter table public.users_boards enable row level security;

create index idx_users_boards_composite_pkey on public.users_boards (user_id, board_id);

create index idx_users_boards_board_id on public.users_boards (board_id);


create or replace function public.set_updated_at()
    RETURNS trigger
    LANGUAGE plpgsql
    AS $$
begin
  new.updated_at = now();
  return new;
end;
$$;


create or replace trigger trg_boards_updated_at
before update on public.boards
for each row execute function public.set_updated_at();


-- RLS for boards

create policy "Users can create boards"
on public.boards
for insert
to authenticated
with check (true);


create policy "Users can view boards they belong to"
on public.boards
for select
to authenticated
using (
  exists (
    select 1
    from public.users_boards ub
    where (ub.user_id, ub.board_id) = ((select auth.uid()), public.boards.id)
  )
);


create policy "Users can update boards they belong to"
on public.boards
for update
to authenticated
using (
  exists (
    select 1
    from public.users_boards ub
    where (ub.user_id, ub.board_id) = ((select auth.uid()), public.boards.id)
  )
)
with check (
  exists (
    select 1
    from public.users_boards ub
    where (ub.user_id, ub.board_id) = ((select auth.uid()), public.boards.id)
  )
);


create policy "Users can delete boards if they're the only member"
on public.boards
for delete
to authenticated
using (
  (
    exists (
      select 1
      from public.users_boards ub
      where (ub.user_id, ub.board_id) = ((select auth.uid()), public.boards.id)
    )
  )
  and (
    (select count(*) from public.users_boards where board_id = public.boards.id) = 1
  )
);


create policy "Users can join boards"
on public.users_boards
for insert
to authenticated
with check (true);


create or replace function public.user_board_ids(uid uuid)
returns setof bigint
language sql
security definer
set search_path = public
as $$
  select board_id from public.users_boards where user_id = uid;
$$;

alter function public.user_board_ids owner to postgres;

revoke all on function public.user_board_ids(uuid) from public;

grant execute on function public.user_board_ids(uuid) to authenticated;


create policy "Users can see their boards, and which users are also in their boards"
on public.users_boards
for select
to authenticated
using (
  board_id in (select * from public.user_board_ids((select auth.uid())))
);


create policy "Users can leave boards"
on public.users_boards
for delete
to authenticated
using (
  user_id = (select auth.uid())
);


-- RLS for columns

create policy "Users can insert columns in their boards"
on public.columns
for insert
to authenticated
with check (
  exists (
    select 1
    from public.users_boards ub
    where (ub.user_id, ub.board_id) = ((select auth.uid()), public.columns.board_id)
  )
);


create policy "Users can view columns in their boards"
on public.columns
for select
to authenticated
using (
  exists (
    select 1
    from public.users_boards ub
    where (ub.user_id, ub.board_id) = ((select auth.uid()), public.columns.board_id)
  )
);


create policy "Users can update columns in their boards"
on public.columns
for update
to authenticated
using (
  exists (
    select 1
    from public.users_boards ub
    where (ub.user_id, ub.board_id) = ((select auth.uid()), public.columns.board_id)
  )
)
with check (
  exists (
    select 1
    from public.users_boards ub
    where (ub.user_id, ub.board_id) = ((select auth.uid()), public.columns.board_id)
  )
);


create policy "Users can delete columns from their boards"
on public.columns
for delete
to authenticated
using (
  exists (
    select 1
    from public.users_boards ub
    where (ub.user_id, ub.board_id) = ((select auth.uid()), public.columns.board_id)
  )
);


-- RLS for tasks

create policy "Users can insert tasks in their own boards"
on public.tasks
for insert
to authenticated
with check (
  exists (
    select 1
    from public.users_boards ub
    where (ub.user_id, ub.board_id) = (
      (select auth.uid()),
      (select c.board_id from public.columns c where c.id = public.tasks.column_id)
    )
  )
);


create policy "Users can view tasks from their own boards"
on public.tasks
for select
to authenticated
using (
  exists (
    select 1
    from public.users_boards ub
    where (ub.user_id, ub.board_id) = (
      (select auth.uid()),
      (select c.board_id from public.columns c where c.id = public.tasks.column_id)
    )
  )
);


create policy "Users can update tasks from their own boards"
on public.tasks
for update
to authenticated
using (
  exists (
    select 1
    from public.users_boards ub
    where (ub.user_id, ub.board_id) = (
      (select auth.uid()),
      (select c.board_id from public.columns c where c.id = public.tasks.column_id)
    )
  )
)
with check (
  exists (
    select 1
    from public.users_boards ub
    where (ub.user_id, ub.board_id) = (
      (select auth.uid()),
      (select c.board_id from public.columns c where c.id = public.tasks.column_id)
    )
  )
);


create policy "Users can delete tasks from their own boards"
on public.tasks
for delete
to authenticated
using (
  exists (
    select 1
    from public.users_boards ub
    where (ub.user_id, ub.board_id) = (
      (select auth.uid()),
      (select c.board_id from public.columns c where c.id = public.tasks.column_id)
    )
  )
);


create or replace function public.create_board (
  title text,
  description text,
  color text,
  creator text
)
returns public.boards
language plpgsql
security definer
as $$
declare
  new_board public.boards;
begin
  if color is null then
    insert into public.boards (title, description, creator)
    values (title, description, creator)
    returning * into new_board;
  else
    insert into public.boards (title, description, color, creator)
    values (title, description, color, creator)
    returning * into new_board;
  end if;

  insert into public.users_boards (user_id, board_id)
  values (auth.uid(), new_board.id);

  return new_board;
end;
$$;

alter function public.create_board owner to postgres;

revoke all on function public.create_board(text, text, text, text) from public;

grant execute on function public.create_board(text, text, text, text) to authenticated;


create or replace function public.get_users_for_board (
  board_id_arg bigint
)
returns table (
  id              uuid,
  full_name       text,
  avatar_img_name text,
  avatar_img_cb   text
)
language plpgsql
security definer
as $$
begin
  return query
  select u.id,
         u.raw_user_meta_data ->> 'full_name',
         u.raw_user_meta_data ->> 'avatar_img_name',
         u.raw_user_meta_data ->> 'avatar_img_cb'
  from auth.users u
  where u.id in (
    select ub.user_id
    from public.users_boards ub
    where ub.board_id = board_id_arg
  );
end;
$$;

alter function public.get_users_for_board owner to postgres;

revoke all on function public.get_users_for_board(bigint) from public;

grant execute on function public.get_users_for_board(bigint) to authenticated;


-- -- Allow authenticated users to receive broadcasts
-- CREATE POLICY "authenticated_users_can_receive"
-- ON realtime.messages
-- FOR SELECT
-- TO authenticated
-- USING (true);

-- -- Allow authenticated users to send broadcasts
-- CREATE POLICY "authenticated_users_can_send"
-- ON realtime.messages
-- FOR INSERT
-- TO authenticated
-- WITH CHECK (true);